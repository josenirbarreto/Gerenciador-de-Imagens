<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Imagens para WebP</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .dropzone {
            border: 2px dashed #cbd5e0;
            transition: all 0.3s ease;
        }
        .dropzone.active {
            border-color: #4f46e5;
            background-color: #eef2ff;
        }
        .editor-container {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .tool-btn {
            transition: all 0.2s ease;
        }
        .tool-btn:hover {
            transform: translateY(-2px);
        }
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
        .canvas-container {
            position: relative;
            overflow: hidden;
        }
        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .preview-image {
            filter: brightness(100%) contrast(100%) saturate(100%);
        }
        .crop-area {
            position: absolute;
            border: 2px dashed #4f46e5;
            background-color: rgba(79, 70, 229, 0.2);
            cursor: move;
            display: none;
        }
        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #4f46e5;
            border: 1px solid white;
        }
        .resize-input {
            width: 80px;
            padding: 0.4rem 0.5rem;
        }
        .crop-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- Modal de Configurações -->
        <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
            <div class="bg-white rounded-xl shadow-lg p-6 w-full max-w-md">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-800">Configurações do Plugin</h3>
                    <button id="closeSettings" class="text-gray-500 hover:text-gray-700">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="space-y-6">
                    <div>
                        <h4 class="font-medium text-gray-700 mb-3">Configurações de Conversão</h4>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Qualidade Padrão</label>
                                <input type="range" id="defaultQuality" min="1" max="100" value="80" class="w-full range-slider">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>Arquivo menor</span>
                                    <span>Melhor qualidade</span>
                                </div>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Tamanho Máximo (px)</label>
                                <div class="flex space-x-2">
                                    <div class="flex-1">
                                        <label class="block text-xs text-gray-500 mb-1">Largura</label>
                                        <input type="number" id="maxWidth" value="1920" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                    </div>
                                    <div class="flex-1">
                                        <label class="block text-xs text-gray-500 mb-1">Altura</label>
                                        <input type="number" id="maxHeight" value="1080" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-gray-700 mb-3">Opções de Upload</h4>
                        <div class="space-y-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="autoConvert" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                                <label for="autoConvert" class="ml-2 block text-sm text-gray-700">Converter automaticamente para WebP ao fazer upload</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="keepOriginal" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                                <label for="keepOriginal" class="ml-2 block text-sm text-gray-700">Manter arquivo original além da versão WebP</label>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-gray-700 mb-3">Configurações de Exibição</h4>
                        <div class="space-y-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="showRecent" checked class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                                <label for="showRecent" class="ml-2 block text-sm text-gray-700">Mostrar envios recentes</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="showTutorial" checked class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                                <label for="showTutorial" class="ml-2 block text-sm text-gray-700">Mostrar dicas de uso</label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="cancelSettings" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
                        Cancelar
                    </button>
                    <button id="saveSettings" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg">
                        Salvar Configurações
                    </button>
                </div>
            </div>
        </div>

        <div class="bg-white rounded-xl shadow-sm p-6 mb-8">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">Editor de Imagens para WebP</h1>
                    <p class="text-gray-600 mt-1">Edite suas imagens e converta para o moderno formato WebP</p>
                </div>
                <div class="flex items-center space-x-3">
                    <span class="px-3 py-1 bg-indigo-100 text-indigo-800 rounded-full text-sm font-medium">v1.0.0</span>
                    <button id="settingsBtn" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg transition flex items-center">
                        <i class="fas fa-cog mr-2"></i> Configurações
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Seção de Upload -->
                <div class="lg:col-span-1">
                    <div class="bg-gray-50 p-5 rounded-lg">
                        <h2 class="text-xl font-semibold text-gray-800 mb-4">Enviar Imagem</h2>
                        
                        <div id="dropzone" class="dropzone rounded-lg p-8 text-center cursor-pointer mb-4">
                            <div class="flex flex-col items-center justify-center">
                                <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-3"></i>
                                <p class="text-gray-600 mb-1">Arraste e solte sua imagem aqui</p>
                                <p class="text-sm text-gray-500">ou</p>
                                <button id="uploadBtn" class="mt-3 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg transition">
                                    Selecionar Imagem
                                </button>
                            </div>
                            <input type="file" id="fileInput" accept="image/*" class="hidden">
                        </div>

                        <div id="recentUploads" class="bg-white p-4 rounded-lg border border-gray-200">
                            <h3 class="font-medium text-gray-700 mb-2">Envios Recentes</h3>
                            <div id="recentFilesList" class="space-y-2">
                                <!-- Os envios recentes serão carregados aqui dinamicamente -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Seção do Editor -->
                <div class="lg:col-span-2">
                    <div class="editor-container bg-white rounded-lg border border-gray-200 overflow-hidden">
                        <div class="p-4 border-b border-gray-200 bg-gray-50">
                            <div class="flex items-center justify-between">
                                <h2 class="text-lg font-semibold text-gray-800">Editor de Imagens</h2>
                                <div class="flex space-x-2">
                                    <button id="resetBtn" class="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 rounded transition">
                                        <i class="fas fa-undo mr-1"></i> Redefinir
                                    </button>
                                    <button id="downloadBtn" class="px-3 py-1 text-sm bg-indigo-600 hover:bg-indigo-700 text-white rounded transition">
                                        <i class="fas fa-download mr-1"></i> Baixar
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="p-4">
                            <div class="canvas-container bg-gray-100 rounded-lg overflow-hidden relative">
                                <canvas id="imageCanvas" class="max-w-full mx-auto block preview-image"></canvas>
                                <div id="loadingSpinner" class="loading-spinner">
                                    <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500"></div>
                                </div>
                                <div id="cropArea" class="crop-area"></div>
                                <div id="cropInfo" class="crop-info hidden"></div>
                            </div>
                            
                            <!-- Adicionado o tamanho original abaixo da imagem -->
                            <div id="imageSizeInfo" class="text-center text-sm text-gray-500 mt-2">
                                Tamanho original: <span id="originalDimensions">-</span> (<span id="originalSizeKB">-</span> KB)
                            </div>

                            <div class="mt-4">
                                <div class="flex flex-wrap gap-2 mb-4">
                                    <button id="cropBtn" class="tool-btn px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition flex items-center">
                                        <i class="fas fa-crop-alt mr-2 text-indigo-600"></i> Cortar
                                    </button>
                                    <button id="applyCropBtn" class="tool-btn px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg transition flex items-center hidden">
                                        <i class="fas fa-check mr-2"></i> Aplicar Corte
                                    </button>
                                    <button id="cancelCropBtn" class="tool-btn px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition flex items-center hidden">
                                        <i class="fas fa-times mr-2"></i> Cancelar
                                    </button>
                                    <button id="rotateBtn" class="tool-btn px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition flex items-center">
                                        <i class="fas fa-redo mr-2 text-indigo-600"></i> Girar
                                    </button>
                                    <button id="flipHBtn" class="tool-btn px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition flex items-center">
                                        <i class="fas fa-arrows-alt-h mr-2 text-indigo-600"></i> Inverter H
                                    </button>
                                    <button id="flipVBtn" class="tool-btn px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition flex items-center">
                                        <i class="fas fa-arrows-alt-v mr-2 text-indigo-600"></i> Inverter V
                                    </button>
                                    <button id="brightnessBtn" class="tool-btn px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition flex items-center">
                                        <i class="fas fa-sun mr-2 text-indigo-600"></i> Brilho
                                    </button>
                                    <button id="contrastBtn" class="tool-btn px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition flex items-center">
                                        <i class="fas fa-adjust mr-2 text-indigo-600"></i> Contraste
                                    </button>
                                </div>

                                <!-- Controles de Ajuste (inicialmente ocultos) -->
                                <div id="adjustmentControls" class="hidden space-y-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Brilho (<span id="brightnessValue">0</span>%)</label>
                                        <input type="range" id="brightnessRange" min="-100" max="100" value="0" class="w-full range-slider">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Contraste (<span id="contrastValue">0</span>%)</label>
                                        <input type="range" id="contrastRange" min="-100" max="100" value="0" class="w-full range-slider">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Saturação (<span id="saturationValue">0</span>%)</label>
                                        <input type="range" id="saturationRange" min="-100" max="100" value="0" class="w-full range-slider">
                                    </div>
                                    <div class="flex justify-end space-x-3">
                                        <button id="cancelAdjustments" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
                                            Cancelar
                                        </button>
                                        <button id="applyAdjustments" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg transition">
                                            Aplicar Ajustes
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Opções de Conversão -->
                        <div class="p-4 border-t border-gray-200 bg-gray-50">
                            <h3 class="font-medium text-gray-700 mb-3">Opções de Conversão para WebP</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Qualidade (0-100)</label>
                                    <input type="range" id="qualityRange" min="1" max="100" value="80" class="w-full range-slider">
                                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                                        <span>Arquivo menor</span>
                                        <span>Melhor qualidade</span>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Redimensionar (opcional)</label>
                                    <div class="flex space-x-2">
                                        <input type="number" id="resizeWidth" placeholder="Largura" class="resize-input px-2 py-1 border border-gray-300 rounded-lg">
                                        <input type="number" id="resizeHeight" placeholder="Altura" class="resize-input px-2 py-1 border border-gray-300 rounded-lg">
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4">
                                <button id="convertBtn" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition font-medium flex items-center justify-center">
                                    <i class="fas fa-file-image mr-2"></i> Converter para WebP
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="tutorialSection" class="bg-white rounded-xl shadow-sm p-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Como usar este aplicativo</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-indigo-50 p-4 rounded-lg">
                        <div class="flex items-center mb-2">
                            <div class="bg-indigo-100 p-2 rounded-full mr-3">
                                <i class="fas fa-upload text-indigo-600"></i>
                            </div>
                            <h3 class="font-medium text-gray-800">Enviar Imagem</h3>
                        </div>
                        <p class="text-sm text-gray-600">Arraste e solte ou clique para selecionar uma imagem do seu computador.</p>
                    </div>
                    <div class="bg-indigo-50 p-4 rounded-lg">
                        <div class="flex items-center mb-2">
                            <div class="bg-indigo-100 p-2 rounded-full mr-3">
                                <i class="fas fa-sliders-h text-indigo-600"></i>
                            </div>
                            <h3 class="font-medium text-gray-800">Editar Imagem</h3>
                        </div>
                        <p class="text-sm text-gray-600">Use as ferramentas de edição para cortar, girar, ajustar cores, etc.</p>
                    </div>
                    <div class="bg-indigo-50 p-4 rounded-lg">
                        <div class="flex items-center mb-2">
                            <div class="bg-indigo-100 p-2 rounded-full mr-3">
                                <i class="fas fa-file-export text-indigo-600"></i>
                            </div>
                            <h3 class="font-medium text-gray-800">Converter & Salvar</h3>
                        </div>
                        <p class="text-sm text-gray-600">Converta para o formato WebP, baixe e salve na sua biblioteca de mídia.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Elementos DOM
            const dropzone = document.getElementById('dropzone');
            const fileInput = document.getElementById('fileInput');
            const uploadBtn = document.getElementById('uploadBtn');
            const imageCanvas = document.getElementById('imageCanvas');
            const ctx = imageCanvas.getContext('2d');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const recentFilesList = document.getElementById('recentFilesList');
            const originalDimensions = document.getElementById('originalDimensions');
            const originalSizeKB = document.getElementById('originalSizeKB');
            const imageSizeInfo = document.getElementById('imageSizeInfo');
            
            // Botões do editor
            const cropBtn = document.getElementById('cropBtn');
            const applyCropBtn = document.getElementById('applyCropBtn');
            const cancelCropBtn = document.getElementById('cancelCropBtn');
            const rotateBtn = document.getElementById('rotateBtn');
            const flipHBtn = document.getElementById('flipHBtn');
            const flipVBtn = document.getElementById('flipVBtn');
            const brightnessBtn = document.getElementById('brightnessBtn');
            const contrastBtn = document.getElementById('contrastBtn');
            
            // Controles de ajuste
            const adjustmentControls = document.getElementById('adjustmentControls');
            const brightnessRange = document.getElementById('brightnessRange');
            const contrastRange = document.getElementById('contrastRange');
            const saturationRange = document.getElementById('saturationRange');
            const brightnessValue = document.getElementById('brightnessValue');
            const contrastValue = document.getElementById('contrastValue');
            const saturationValue = document.getElementById('saturationValue');
            const applyAdjustments = document.getElementById('applyAdjustments');
            const cancelAdjustments = document.getElementById('cancelAdjustments');
            
            // Controles de conversão
            const qualityRange = document.getElementById('qualityRange');
            const resizeWidth = document.getElementById('resizeWidth');
            const resizeHeight = document.getElementById('resizeHeight');
            const convertBtn = document.getElementById('convertBtn');
            const resetBtn = document.getElementById('resetBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            
            // Configurações
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettings = document.getElementById('closeSettings');
            const cancelSettings = document.getElementById('cancelSettings');
            const saveSettings = document.getElementById('saveSettings');
            const defaultQuality = document.getElementById('defaultQuality');
            const maxWidth = document.getElementById('maxWidth');
            const maxHeight = document.getElementById('maxHeight');
            const autoConvert = document.getElementById('autoConvert');
            const keepOriginal = document.getElementById('keepOriginal');
            const showRecent = document.getElementById('showRecent');
            const showTutorial = document.getElementById('showTutorial');
            const recentUploads = document.getElementById('recentUploads');
            const tutorialSection = document.getElementById('tutorialSection');
            
            // Elementos de corte
            const cropArea = document.getElementById('cropArea');
            const cropInfo = document.getElementById('cropInfo');
            
            // Variáveis de estado
            let originalImage = null;
            let currentImage = null;
            let isEditing = false;
            let recentFiles = [];
            let currentFileName = '';
            let currentFileSizeKB = 0;
            let isCropping = false;
            let cropStartX = 0;
            let cropStartY = 0;
            let cropMoveX = 0;
            let cropMoveY = 0;
            let isDragging = false;
            let cropResizing = false;
            let cropResizeHandle = null;
            let originalAdjustments = {};
            let tempCanvas = null;
            let originalImageWidth = 0;
            let originalImageHeight = 0;
            let isDrawingCrop = false;
            let cropStartPos = { x: 0, y: 0 };
            let cropBeforeState = null;
            
            // Configurações padrão
            let settings = {
                defaultQuality: 80,
                maxWidth: 1920,
                maxHeight: 1080,
                autoConvert: false,
                keepOriginal: true,
                showRecent: true,
                showTutorial: true
            };
            
            // Carrega configurações do localStorage
            function loadSettings() {
                const savedSettings = localStorage.getItem('webpEditorSettings');
                if (savedSettings) {
                    settings = JSON.parse(savedSettings);
                }
                
                // Aplica as configurações carregadas
                defaultQuality.value = settings.defaultQuality;
                maxWidth.value = settings.maxWidth;
                maxHeight.value = settings.maxHeight;
                autoConvert.checked = settings.autoConvert;
                keepOriginal.checked = settings.keepOriginal;
                showRecent.checked = settings.showRecent;
                showTutorial.checked = settings.showTutorial;
                
                // Aplica qualidade padrão ao slider
                qualityRange.value = settings.defaultQuality;
                
                // Mostra/oculta seções conforme configurações
                recentUploads.style.display = settings.showRecent ? 'block' : 'none';
                tutorialSection.style.display = settings.showTutorial ? 'block' : 'none';
            }
            
            // Salva configurações no localStorage
            function saveSettingsToStorage() {
                settings = {
                    defaultQuality: parseInt(defaultQuality.value),
                    maxWidth: parseInt(maxWidth.value),
                    maxHeight: parseInt(maxHeight.value),
                    autoConvert: autoConvert.checked,
                    keepOriginal: keepOriginal.checked,
                    showRecent: showRecent.checked,
                    showTutorial: showTutorial.checked
                };
                
                localStorage.setItem('webpEditorSettings', JSON.stringify(settings));
                
                // Aplica as novas configurações
                qualityRange.value = settings.defaultQuality;
                recentUploads.style.display = settings.showRecent ? 'block' : 'none';
                tutorialSection.style.display = settings.showTutorial ? 'block' : 'none';
            }
            
            // Carrega envios recentes do localStorage
            function loadRecentFiles() {
                const savedFiles = localStorage.getItem('webpEditorRecentFiles');
                if (savedFiles) {
                    recentFiles = JSON.parse(savedFiles);
                    updateRecentFilesList();
                }
            }
            
            // Atualiza la lista de envios recentes na UI
            function updateRecentFilesList() {
                recentFilesList.innerHTML = '';
                
                if (recentFiles.length === 0) {
                    recentFilesList.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">Nenhum arquivo recente</p>';
                    return;
                }
                
                recentFiles.forEach((file, index) => {
                    const fileElement = document.createElement('div');
                    fileElement.className = 'flex items-center p-2 hover:bg-gray-50 rounded cursor-pointer';
                    fileElement.innerHTML = `
                        <img src="${file.thumbnail}" alt="Thumbnail" class="w-10 h-10 rounded object-cover">
                        <div class="ml-3">
                            <p class="text-sm font-medium text-gray-800">${file.name}</p>
                            <p class="text-xs text-gray-500">${formatDate(file.date)}</p>
                        </div>
                    `;
                    
                    fileElement.addEventListener('click', () => {
                        loadRecentFile(file);
                    });
                    
                    recentFilesList.appendChild(fileElement);
                });
            }
            
            // Formata data para exibição
            function formatDate(dateString) {
                const date = new Date(dateString);
                const now = new Date();
                const diffInSeconds = Math.floor((now - date) / 1000);
                
                if (diffInSeconds < 60) return 'agora mesmo';
                if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutos atrás`;
                if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} horas atrás`;
                
                return `${Math.floor(diffInSeconds / 86400)} dias atrás`;
            }
            
            // Carrega um arquivo recente
            function loadRecentFile(file) {
                showLoading(true);
                
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    currentImage = img;
                    originalImageWidth = img.width;
                    originalImageHeight = img.height;
                    currentFileName = file.name.replace(/\.[^/.]+$/, "");
                    currentFileSizeKB = Math.round(file.sizeKB);
                    setupCanvas(img);
                    updateImageSizeInfo();
                    showLoading(false);
                };
                img.src = file.dataUrl;
            }
            
            // Adiciona um arquivo à lista de recentes
            function addToRecentFiles(fileName, dataUrl) {
                // Cria uma miniatura para o arquivo
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 40;
                    canvas.height = 40;
                    ctx.drawImage(img, 0, 0, 40, 40);
                    const thumbnail = canvas.toDataURL('image/jpeg', 0.7);
                    
                    // Calcula o tamanho em KB
                    const base64Length = dataUrl.length - (dataUrl.indexOf(',') + 1);
                    const padding = dataUrl.charAt(dataUrl.length - 2) === '=' ? 2 : dataUrl.charAt(dataUrl.length - 1) === '=' ? 1 : 0;
                    const fileSizeBytes = Math.floor(base64Length * 0.75) - padding;
                    const fileSizeKB = Math.round(fileSizeBytes / 1024);
                    
                    // Verifica se o arquivo já existe na lista
                    const existingIndex = recentFiles.findIndex(file => file.name === fileName);
                    
                    if (existingIndex >= 0) {
                        // Atualiza o arquivo existente
                        recentFiles[existingIndex] = {
                            name: fileName,
                            dataUrl: dataUrl,
                            thumbnail: thumbnail,
                            date: new Date().toISOString(),
                            sizeKB: fileSizeKB
                        };
                    } else {
                        // Adiciona novo arquivo à lista
                        recentFiles.unshift({
                            name: fileName,
                            dataUrl: dataUrl,
                            thumbnail: thumbnail,
                            date: new Date().toISOString(),
                            sizeKB: fileSizeKB
                        });
                    }
                    
                    // Mantém apenas os 5 mais recentes
                    if (recentFiles.length > 5) {
                        recentFiles = recentFiles.slice(0, 5);
                    }
                    
                    // Salva no localStorage
                    localStorage.setItem('webpEditorRecentFiles', JSON.stringify(recentFiles));
                    
                    // Atualiza a UI
                    updateRecentFilesList();
                };
                img.src = dataUrl;
            }
            
            // Inicializa o modal de configurações
            function initSettingsModal() {
                settingsBtn.addEventListener('click', () => {
                    settingsModal.style.display = 'flex';
                });
                
                closeSettings.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                });
                
                cancelSettings.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                });
                
                saveSettings.addEventListener('click', () => {
                    saveSettingsToStorage();
                    settingsModal.style.display = 'none';
                });
                
                // Fecha o modal ao clicar fora
                settingsModal.addEventListener('click', (e) => {
                    if (e.target === settingsModal) {
                        settingsModal.style.display = 'none';
                    }
                });
            }
            
            // Inicializa a funcionalidade de corte
            function initCropFunctionality() {
                cropBtn.addEventListener('click', startCropMode);
                applyCropBtn.addEventListener('click', applyCropToImage);
                cancelCropBtn.addEventListener('click', cancelCropAction);
                
                // Eventos para arrastar a área de corte
                cropArea.addEventListener('mousedown', startDraggingCrop);
                imageCanvas.addEventListener('mousedown', startDrawingCrop);
                document.addEventListener('mousemove', dragCrop);
                document.addEventListener('mouseup', stopDraggingCrop);
            }
            
            // Inicia o modo de corte
            function startCropMode() {
                if (!currentImage) {
                    alert('Por favor, envie uma imagem primeiro');
                    return;
                }
                
                // Salva o estado atual antes de começar o corte
                cropBeforeState = {
                    image: currentImage,
                    width: imageCanvas.width,
                    height: imageCanvas.height
                };
                
                // Ativa o modo de corte
                isCropping = true;
                cropArea.style.display = 'block';
                cropInfo.style.display = 'block';
                
                // Mostra os botões de aplicar/cancelar corte
                cropBtn.classList.add('hidden');
                applyCropBtn.classList.remove('hidden');
                cancelCropBtn.classList.remove('hidden');
                
                // Define a área de corte inicial (metade da imagem)
                const initialWidth = Math.floor(imageCanvas.width / 2);
                const initialHeight = Math.floor(imageCanvas.height / 2);
                const initialX = Math.floor((imageCanvas.width - initialWidth) / 2);
                const initialY = Math.floor((imageCanvas.height - initialHeight) / 2);
                
                updateCropArea(initialX, initialY, initialWidth, initialHeight);
                
                // Adiciona manipuladores de redimensionamento
                addCropHandles();
            }
            
            // Adiciona manipuladores de redimensionamento à área de corte
            function addCropHandles() {
                // Remove quaisquer manipuladores existentes
                removeCropHandles();
                
                // Cria manipuladores nos cantos e laterais
                const positions = [
                    { class: 'crop-handle-nw', cursor: 'nw-resize', left: '0', top: '0' },
                    { class: 'crop-handle-ne', cursor: 'ne-resize', right: '0', top: '0' },
                    { class: 'crop-handle-sw', cursor: 'sw-resize', left: '0', bottom: '0' },
                    { class: 'crop-handle-se', cursor: 'se-resize', right: '0', bottom: '0' },
                    { class: 'crop-handle-n', cursor: 'n-resize', left: '50%', top: '0', transform: 'translateX(-50%)' },
                    { class: 'crop-handle-s', cursor: 's-resize', left: '50%', bottom: '0', transform: 'translateX(-50%)' },
                    { class: 'crop-handle-w', cursor: 'w-resize', left: '0', top: '50%', transform: 'translateY(-50%)' },
                    { class: 'crop-handle-e', cursor: 'e-resize', right: '0', top: '50%', transform: 'translateY(-50%)' }
                ];
                
                positions.forEach(pos => {
                    const handle = document.createElement('div');
                    handle.className = `crop-handle ${pos.class}`;
                    handle.style.position = 'absolute';
                    handle.style.width = '10px';
                    handle.style.height = '10px';
                    handle.style.backgroundColor = '#4f46e5';
                    handle.style.border = '1px solid white';
                    handle.style.cursor = pos.cursor;
                    
                    // Posicionamento
                    if (pos.left) handle.style.left = pos.left;
                    if (pos.right) handle.style.right = pos.right;
                    if (pos.top) handle.style.top = pos.top;
                    if (pos.bottom) handle.style.bottom = pos.bottom;
                    if (pos.transform) handle.style.transform = pos.transform;
                    
                    // Eventos de redimensionamento
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        cropResizing = true;
                        cropResizeHandle = pos.class.split('-')[2]; // pega a direção (nw, ne, etc)
                        startDraggingCrop(e);
                    });
                    
                    cropArea.appendChild(handle);
                });
            }
            
            // Remove os manipuladores de redimensionamento
            function removeCropHandles() {
                const handles = document.querySelectorAll('.crop-handle');
                handles.forEach(handle => handle.remove());
            }
            
            // Cancela a ação de corte
            function cancelCropAction() {
                isCropping = false;
                cropArea.style.display = 'none';
                cropInfo.style.display = 'none';
                removeCropHandles();
                isDrawingCrop = false;
                
                // Restaura os botões normais
                cropBtn.classList.remove('hidden');
                applyCropBtn.classList.add('hidden');
                cancelCropBtn.classList.add('hidden');
                
                // Restaura a imagem ao estado antes do corte
                if (cropBeforeState) {
                    currentImage = cropBeforeState.image;
                    imageCanvas.width = cropBeforeState.width;
                    imageCanvas.height = cropBeforeState.height;
                    ctx.drawImage(currentImage, 0, 0);
                }
            }
            
            // Atualiza a posição e tamanho da área de corte
            function updateCropArea(x, y, width, height) {
                // Limita as coordenadas para não sair do canvas
                width = Math.max(50, Math.min(width, imageCanvas.width));
                height = Math.max(50, Math.min(height, imageCanvas.height));
                
                x = Math.max(0, Math.min(x, imageCanvas.width - width));
                y = Math.max(0, Math.min(y, imageCanvas.height - height));
                
                // Posiciona a área de corte
                cropArea.style.left = `${x}px`;
                cropArea.style.top = `${y}px`;
                cropArea.style.width = `${width}px`;
                cropArea.style.height = `${height}px`;
                
                // Atualiza a informação de corte
                cropInfo.textContent = `${width} × ${height} px`;
                
                // Atualiza os manipuladores de redimensionamento
                if (isCropping) {
                    addCropHandles();
                }
            }
            
            // Inicia o desenho da área de corte
            function startDrawingCrop(e) {
                if (!isCropping || cropArea.contains(e.target)) return;
                
                const canvasRect = imageCanvas.getBoundingClientRect();
                const mouseX = e.clientX - canvasRect.left;
                const mouseY = e.clientY - canvasRect.top;
                
                isDrawingCrop = true;
                cropStartPos = { x: mouseX, y: mouseY };
                
                // Define a área de corte inicial
                updateCropArea(mouseX, mouseY, 0, 0);
                
                e.preventDefault();
            }
            
            // Inicia o arraste da área de corte
            function startDraggingCrop(e) {
                if (!isCropping) return;
                
                isDragging = true;
                cropStartX = e.clientX;
                cropStartY = e.clientY;
                
                // Salva a posição inicial da área de corte
                const rect = cropArea.getBoundingClientRect();
                cropMoveX = rect.left - imageCanvas.getBoundingClientRect().left;
                cropMoveY = rect.top - imageCanvas.getBoundingClientRect().top;
                
                e.preventDefault();
            }
            
            // Arrasta a área de corte
            function dragCrop(e) {
                if (!isCropping) return;
                
                const canvasRect = imageCanvas.getBoundingClientRect();
                const mouseX = e.clientX - canvasRect.left;
                const mouseY = e.clientY - canvasRect.top;
                
                if (isDrawingCrop) {
                    // Desenha a área de corte com o mouse
                    const width = mouseX - cropStartPos.x;
                    const height = mouseY - cropStartPos.y;
                    
                    updateCropArea(
                        width > 0 ? cropStartPos.x : mouseX,
                        height > 0 ? cropStartPos.y : mouseY,
                        Math.abs(width),
                        Math.abs(height)
                    );
                } 
                else if (isDragging) {
                    if (cropResizing) {
                        // Redimensionamento da área de corte
                        const width = parseInt(cropArea.style.width);
                        const height = parseInt(cropArea.style.height);
                        const x = parseInt(cropArea.style.left);
                        const y = parseInt(cropArea.style.top);
                        
                        let newWidth = width;
                        let newHeight = height;
                        let newX = x;
                        let newY = y;
                        
                        // Calcula novas dimensões com base na direção do redimensionamento
                        switch (cropResizeHandle) {
                            case 'nw':
                                newWidth = width + (cropStartX - e.clientX);
                                newHeight = height + (cropStartY - e.clientY);
                                newX = x - (cropStartX - e.clientX);
                                newY = y - (cropStartY - e.clientY);
                                break;
                            case 'ne':
                                newWidth = width + (e.clientX - cropStartX);
                                newHeight = height + (cropStartY - e.clientY);
                                newY = y - (cropStartY - e.clientY);
                                break;
                            case 'sw':
                                newWidth = width + (cropStartX - e.clientX);
                                newHeight = height + (e.clientY - cropStartY);
                                newX = x - (cropStartX - e.clientX);
                                break;
                            case 'se':
                                newWidth = width + (e.clientX - cropStartX);
                                newHeight = height + (e.clientY - cropStartY);
                                break;
                            case 'n':
                                newHeight = height + (cropStartY - e.clientY);
                                newY = y - (cropStartY - e.clientY);
                                break;
                            case 's':
                                newHeight = height + (e.clientY - cropStartY);
                                break;
                            case 'w':
                                newWidth = width + (cropStartX - e.clientX);
                                newX = x - (cropStartX - e.clientX);
                                break;
                            case 'e':
                                newWidth = width + (e.clientX - cropStartX);
                                break;
                        }
                        
                        // Mantém a proporção se a tecla Shift estiver pressionada
                        if (e.shiftKey) {
                            const aspectRatio = width / height;
                            
                            if (cropResizeHandle.includes('e') || cropResizeHandle.includes('w')) {
                                newHeight = newWidth / aspectRatio;
                                if (cropResizeHandle.includes('n')) {
                                    newY = y - (newHeight - height);
                                }
                            } else {
                                newWidth = newHeight * aspectRatio;
                                if (cropResizeHandle.includes('w')) {
                                    newX = x - (newWidth - width);
                                }
                            }
                        }
                        
                        updateCropArea(newX, newY, newWidth, newHeight);
                        cropStartX = e.clientX;
                        cropStartY = e.clientY;
                    } else {
                        // Movimento da área de corte
                        const dx = e.clientX - cropStartX;
                        const dy = e.clientY - cropStartY;
                        
                        const newX = cropMoveX + dx;
                        const newY = cropMoveY + dy;
                        
                        updateCropArea(newX, newY, parseInt(cropArea.style.width), parseInt(cropArea.style.height));
                    }
                }
            }
            
            // Para de arrastar a área de corte
            function stopDraggingCrop() {
                isDragging = false;
                cropResizing = false;
                cropResizeHandle = null;
                isDrawingCrop = false;
            }
            
            // Aplica o corte à imagem
            function applyCropToImage() {
                showLoading(true);
                
                const x = parseInt(cropArea.style.left) || 0;
                const y = parseInt(cropArea.style.top) || 0;
                const width = parseInt(cropArea.style.width) || imageCanvas.width;
                const height = parseInt(cropArea.style.height) || imageCanvas.height;
                
                // Cria um canvas temporário para o corte
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Desenha apenas a parte cortada
                tempCtx.drawImage(
                    imageCanvas,
                    x, y, width, height, // Coordenadas de origem
                    0, 0, width, height  // Coordenadas de destino
                );
                
                // Redimensiona o canvas principal
                imageCanvas.width = width;
                imageCanvas.height = height;
                ctx.drawImage(tempCanvas, 0, 0);
                
                // Atualiza a imagem atual
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    originalImage = img; // Atualiza também a imagem original
                    originalImageWidth = img.width;
                    originalImageHeight = img.height;
                    
                    // Atualiza o tamanho em KB estimado
                    const quality = 0.8; // Estimativa de qualidade
                    const bytesPerPixel = 4; // RGBA
                    const estimatedSizeBytes = width * height * bytesPerPixel * quality;
                    currentFileSizeKB = Math.round(estimatedSizeBytes / 1024);
                    
                    updateImageSizeInfo();
                    showLoading(false);
                    
                    // Desativa o modo de corte
                    isCropping = false;
                    cropArea.style.display = 'none';
                    cropInfo.style.display = 'none';
                    removeCropHandles();
                    
                    // Restaura os botões normais
                    cropBtn.classList.remove('hidden');
                    applyCropBtn.classList.add('hidden');
                    cancelCropBtn.classList.add('hidden');
                };
                img.src = imageCanvas.toDataURL();
            }
            
            // Atualiza a informação do tamanho da imagem
            function updateImageSizeInfo() {
                if (originalImageWidth && originalImageHeight) {
                    originalDimensions.textContent = `${originalImageWidth} × ${originalImageHeight} px`;
                    originalSizeKB.textContent = currentFileSizeKB;
                    imageSizeInfo.style.display = 'block';
                } else {
                    imageSizeInfo.style.display = 'none';
                }
            }
            
            // Event Listeners
            uploadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            
            // Funcionalidade de arrastar e soltar
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('active');
            });
            
            dropzone.addEventListener('dragleave', () => {
                dropzone.classList.remove('active');
            });
            
            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('active');
                
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    handleFileSelect({ target: fileInput });
                }
            });
            
            // Botões do editor
            brightnessBtn.addEventListener('click', () => toggleAdjustmentControls('brightness'));
            contrastBtn.addEventListener('click', () => toggleAdjustmentControls('contrast'));
            
            brightnessRange.addEventListener('input', updatePreviewAdjustments);
            contrastRange.addEventListener('input', updatePreviewAdjustments);
            saturationRange.addEventListener('input', updatePreviewAdjustments);
            
            applyAdjustments.addEventListener('click', applyImageAdjustments);
            cancelAdjustments.addEventListener('click', cancelImageAdjustments);
            
            rotateBtn.addEventListener('click', rotateImage);
            flipHBtn.addEventListener('click', () => flipImage('horizontal'));
            flipVBtn.addEventListener('click', () => flipImage('vertical'));
            
            convertBtn.addEventListener('click', convertToWebP);
            resetBtn.addEventListener('click', resetImage);
            downloadBtn.addEventListener('click', downloadImage);
            
            // Funções
            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!file.type.match('image.*')) {
                    alert('Por favor, selecione um arquivo de imagem');
                    return;
                }
                
                showLoading(true);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        originalImage = img;
                        currentImage = img;
                        originalImageWidth = img.width;
                        originalImageHeight = img.height;
                        currentFileName = file.name.replace(/\.[^/.]+$/, "");
                        currentFileSizeKB = Math.round(file.size / 1024);
                        setupCanvas(img);
                        updateImageSizeInfo();
                        showLoading(false);
                        
                        // Adiciona à lista de recentes
                        addToRecentFiles(file.name, e.target.result);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            function setupCanvas(img) {
                // Define as dimensões do canvas para corresponder à imagem (com restrições de largura/altura máximas)
                let width = img.width;
                let height = img.height;
                
                if (width > settings.maxWidth) {
                    height = (settings.maxWidth / width) * height;
                    width = settings.maxWidth;
                }
                
                if (height > settings.maxHeight) {
                    width = (settings.maxHeight / height) * width;
                    height = settings.maxHeight;
                }
                
                imageCanvas.width = width;
                imageCanvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
            }
            
            function showLoading(show) {
                if (show) {
                    loadingSpinner.style.display = 'block';
                } else {
                    loadingSpinner.style.display = 'none';
                }
            }
            
            function toggleAdjustmentControls(type) {
                if (isEditing && adjustmentControls.style.display === 'block') {
                    adjustmentControls.classList.add('hidden');
                    isEditing = false;
                    
                    // Cancela os ajustes se estiverem sendo editados
                    cancelImageAdjustments();
                } else {
                    adjustmentControls.classList.remove('hidden');
                    isEditing = true;
                    
                    // Salva o estado original antes de fazer ajustes
                    saveOriginalState();
                    
                    // Redefine os sliders
                    brightnessRange.value = 0;
                    contrastRange.value = 0;
                    saturationRange.value = 0;
                    brightnessValue.textContent = '0';
                    contrastValue.textContent = '0';
                    saturationValue.textContent = '0';
                    
                    // Atualiza a pré-visualização
                    updatePreviewAdjustments();
                }
            }
            
            // Salva o estado original da imagem antes de aplicar ajustes
            function saveOriginalState() {
                if (!tempCanvas) {
                    tempCanvas = document.createElement('canvas');
                    tempCanvas.width = imageCanvas.width;
                    tempCanvas.height = imageCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(imageCanvas, 0, 0);
                }
                
                originalAdjustments = {
                    brightness: 0,
                    contrast: 0,
                    saturation: 0
                };
            }
            
            // Atualiza a pré-visualização dos ajustes
            function updatePreviewAdjustments() {
                if (!isEditing || !tempCanvas) return;
                
                const brightness = parseInt(brightnessRange.value);
                const contrast = parseInt(contrastRange.value);
                const saturation = parseInt(saturationRange.value);
                
                // Atualiza os valores exibidos
                brightnessValue.textContent = brightness;
                contrastValue.textContent = contrast;
                saturationValue.textContent = saturation;
                
                // Aplica filtros à imagem original
                ctx.filter = `
                    brightness(${100 + brightness}%)
                    contrast(${100 + contrast}%)
                    saturate(${100 + saturation}%)
                `;
                
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0, imageCanvas.width, imageCanvas.height);
            }
            
            // Aplica os ajustes permanentemente à imagem
            function applyImageAdjustments() {
                if (!isEditing) return;
                
                // Remove o filtro para as próximas operações
                ctx.filter = 'none';
                
                // Atualiza a imagem atual
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    
                    // Limpa o canvas temporário
                    if (tempCanvas) {
                        tempCanvas = null;
                    }
                    
                    // Oculta os controles de ajuste
                    adjustmentControls.classList.add('hidden');
                    isEditing = false;
                };
                img.src = imageCanvas.toDataURL();
            }
            
            // Cancela os ajustes e restaura a imagem original
            function cancelImageAdjustments() {
                if (!isEditing) return;
                
                // Restaura a imagem original
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0, imageCanvas.width, imageCanvas.height);
                
                // Remove o filtro
                ctx.filter = 'none';
                
                // Limpa o canvas temporário
                tempCanvas = null;
                
                // Oculta os controles de ajuste
                adjustmentControls.classList.add('hidden');
                isEditing = false;
            }
            
            function rotateImage() {
                if (!currentImage) return;
                
                showLoading(true);
                
                // Salva o estado atual do canvas
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                
                // Troca largura e altura
                [imageCanvas.width, imageCanvas.height] = [imageCanvas.height, imageCanvas.width];
                
                // Limpa o canvas antes de desenhar
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                
                // Gira 90 graus no sentido horário
                ctx.translate(imageCanvas.width / 2, imageCanvas.height / 2);
                ctx.rotate(Math.PI / 2);
                ctx.drawImage(currentImage, -currentImage.height / 2, -currentImage.width / 2);
                
                // Redefine a transformação
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Atualiza a imagem atual
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    originalImage = img; // Atualiza também a imagem original
                    originalImageWidth = img.width;
                    originalImageHeight = img.height;
                    updateImageSizeInfo();
                    showLoading(false);
                };
                img.src = imageCanvas.toDataURL();
            }
            
            function flipImage(direction) {
                if (!currentImage) return;
                
                showLoading(true);
                
                // Limpa o canvas antes de desenhar
                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                
                ctx.save();
                
                if (direction === 'horizontal') {
                    // Inverte horizontalmente
                    ctx.translate(imageCanvas.width, 0);
                    ctx.scale(-1, 1);
                } else {
                    // Inverte verticalmente
                    ctx.translate(0, imageCanvas.height);
                    ctx.scale(1, -1);
                }
                
                ctx.drawImage(currentImage, 0, 0, imageCanvas.width, imageCanvas.height);
                ctx.restore();
                
                // Atualiza a imagem atual
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    originalImage = img; // Atualiza também a imagem original
                    showLoading(false);
                };
                img.src = imageCanvas.toDataURL();
            }
            
            function convertToWebP() {
                if (!currentImage) {
                    alert('Por favor, envie uma imagem primeiro');
                    return;
                }
                
                showLoading(true);
                
                const quality = parseInt(qualityRange.value) / 100;
                let width = imageCanvas.width;
                let height = imageCanvas.height;
                
                // Verifica se valores de redimensionamento foram fornecidos
                if (resizeWidth.value && !isNaN(resizeWidth.value)) {
                    width = parseInt(resizeWidth.value);
                    // Mantém a proporção se apenas a largura foi fornecida
                    if (!resizeHeight.value || isNaN(resizeHeight.value)) {
                        height = (width / imageCanvas.width) * imageCanvas.height;
                    }
                }
                
                if (resizeHeight.value && !isNaN(resizeHeight.value)) {
                    height = parseInt(resizeHeight.value);
                    // Mantém a proporção se apenas a altura foi fornecida
                    if (!resizeWidth.value || isNaN(resizeWidth.value)) {
                        width = (height / imageCanvas.height) * imageCanvas.width;
                    }
                }
                
                // Cria um canvas temporário para redimensionamento
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Desenha a imagem com as novas dimensões
                tempCtx.drawImage(currentImage, 0, 0, width, height);
                
                // Converte para WebP mantendo o nome original com extensão .webp
                tempCanvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = currentFileName + '.webp';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showLoading(false);
                    
                    // Mostra mensagem de sucesso
                    alert('Imagem convertida para formato WebP com sucesso!');
                    
                    // Adiciona a versão WebP aos recentes
                    tempCanvas.toBlob(function(webpBlob) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            addToRecentFiles(currentFileName + '.webp', e.target.result);
                        };
                        reader.readAsDataURL(webpBlob);
                    }, 'image/webp', quality);
                }, 'image/webp', quality);
            }
            
            function resetImage() {
                if (!originalImage) return;
                
                currentImage = originalImage;
                setupCanvas(originalImage);
                updateImageSizeInfo();
                
                // Remove quaisquer ajustes pendentes
                if (isEditing) {
                    cancelImageAdjustments();
                }
                
                // Cancela o corte se estiver ativo
                if (isCropping) {
                    cancelCropAction();
                }
            }
            
            function downloadImage() {
                if (!currentImage) {
                    alert('Por favor, envie uma imagem primeiro');
                    return;
                }
                
                const link = document.createElement('a');
                link.download = currentFileName ? currentFileName + '.png' : 'imagem-editada.png';
                link.href = imageCanvas.toDataURL('image/png');
                link.click();
            }
            
            // Inicializa o plugin
            loadSettings();
            loadRecentFiles();
            initSettingsModal();
            initCropFunctionality();
            
            // Esconde inicialmente a informação de tamanho
            imageSizeInfo.style.display = 'none';
        });
    </script>
    <div id="tutorialSection" class="bg-white rounded-xl shadow-sm p-6">
        <h4 class="text-xl font-semibold text-gray-800 mb-4">Desenvolvido por Josenir Barreto</h4>
        </div>
</body>

</html>
